[{"path":"/articles/aussiemaps.html","id":"aussiemaps---yet-another-maps-package","dir":"Articles","previous_headings":"","what":"{aussiemaps} - Yet another maps package","title":"How to use aussiemaps","text":"package built facilitate use geographic boundary files published Australian Bureau Statistics (ABS). ABS published several boundary files - .e. Australian Statistical Geography Standard (ASGS) 2006 onwards Australian Standard Geographical Classification (ASGC) - covering : Statistical Geographic Structures created maintained ABS - used collect data. Non-ABS structure, e.g Postal Areas, Electoral Divisions, LGA boundaries. package four versions , aligned Census years 2006, 2011,2016 2021. makes easy mix use Census data packs {auscensus} package. package provides access processed version boundaries - sf objects, allowing cater following scenarios: Get boundaries electoral division across time. Get S1 S1 areas within Council area. Get postcodes state territory. repository also contains R script used process files. Although tested, functions also accommodate BYO structures years.","code":""},{"path":"/articles/aussiemaps.html","id":"getting-started-","dir":"Articles","previous_headings":"","what":"Getting started.","title":"How to use aussiemaps","text":"core function package get_map(), retrieves sf files. get_map provides several filters narrow data retrieved avoid getting everything unless needed. key parameters function : data filtered (e.g. return objects particular state, council metro area) year/version data retrieved? aggregation used (e.g. resulting objects) Filters column names follow name convention used original ABS files. function list_attributes(), present tibble format: Let’s say want retrieve SA1 City Melbourne 2016 - can done via:","code":"list_attributes() |>   head(10) #> # A tibble: 10 × 5 #>    attributes `2006`         `2011`         `2016`         `2021`         #>    <chr>      <chr>          <chr>          <chr>          <chr>          #>  1 CD_CODE    CD_CODE_2006   <NA>           <NA>           <NA>           #>  2 CED_CODE   CED_CODE_2006  CED_CODE_2011  CED_CODE_2016  CED_CODE_2021  #>  3 CED_NAME   CED_NAME_2006  CED_NAME_2011  CED_NAME_2016  CED_NAME_2021  #>  4 IARE_CODE  IARE_CODE_2006 IARE_CODE_2011 IARE_CODE_2016 IARE_CODE_2021 #>  5 IARE_NAME  IARE_NAME_2006 IARE_NAME_2011 IARE_NAME_2016 IARE_NAME_2021 #>  6 ILOC_CODE  ILOC_CODE_2006 ILOC_CODE_2011 ILOC_CODE_2016 ILOC_CODE_2021 #>  7 ILOC_NAME  ILOC_NAME_2006 ILOC_NAME_2011 ILOC_NAME_2016 ILOC_NAME_2021 #>  8 IREG_CODE  IREG_CODE_2006 IREG_CODE_2011 IREG_CODE_2016 IREG_CODE_2021 #>  9 IREG_NAME  IREG_NAME_2006 IREG_NAME_2011 IREG_NAME_2016 IREG_NAME_2021 #> 10 LGA_CODE   LGA_CODE_2006  LGA_CODE_2011  LGA_CODE_2016  LGA_CODE_2022 melbourne_sa1 <- get_map(filters=list(LGA_NAME_2016=c(\"Melbourne\")),                          year=2016,                          aggregation = c(\"SA1_MAINCODE_2016\")) #> Updating layer `id' to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg' using driver `GPKG' #> Writing 249 features with 36 fields without geometries. #> Reading query `SELECT * FROM '2016_Victoria' WHERE id IN (SELECT id FROM id)' #> from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg' using driver `GPKG' #> Simple feature collection with 249 features and 37 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 144.8971 ymin: -37.85067 xmax: 144.9914 ymax: -37.77545 #> Geodetic CRS:  GDA94  #just an empty plot  melbourne_sa1 |>   ggplot()+   geom_sf(fill=\"azure1\") +   theme_void() +   labs(title=\"SA1s in the City of Melbourne\")"},{"path":"/articles/aussiemaps.html","id":"filtering-via-regular-expressions","dir":"Articles","previous_headings":"","what":"Filtering via regular expressions","title":"How to use aussiemaps","text":"filter arguments intended regular expressions, instance: Whereas","code":"preston <- get_map(filters=list(SSC_NAME_2016=c(\"Preston\")),                          year=2016,                          aggregation = c(\"SSC_NAME_2016\")) #> Updating layer `id' to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg' using driver `GPKG' #> Writing 119 features with 36 fields without geometries. #> Reading query `SELECT * FROM '2016_New.South.Wales' WHERE id IN (SELECT id FROM id)' #> from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg' using driver `GPKG' #> Simple feature collection with 36 features and 35 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 150.8487 ymin: -33.95678 xmax: 150.8979 ymax: -33.9263 #> Geodetic CRS:  GDA94 #> Updating layer `id' to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg' using driver `GPKG' #> Writing 119 features with 36 fields without geometries. #> Reading query `SELECT * FROM '2016_Queensland' WHERE id IN (SELECT id FROM id)' #> from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg' using driver `GPKG' #> Simple feature collection with 5 features and 35 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 148.6178 ymin: -27.68302 xmax: 152.0004 ymax: -20.34465 #> Geodetic CRS:  GDA94 #> Updating layer `id' to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg' using driver `GPKG' #> Writing 119 features with 36 fields without geometries. #> Reading query `SELECT * FROM '2016_Tasmania' WHERE id IN (SELECT id FROM id)' #> from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg' using driver `GPKG' #> Simple feature collection with 2 features and 35 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 145.9943 ymin: -41.3658 xmax: 146.1147 ymax: -41.24951 #> Geodetic CRS:  GDA94 #> Updating layer `id' to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg' using driver `GPKG' #> Writing 119 features with 36 fields without geometries. #> Reading query `SELECT * FROM '2016_Victoria' WHERE id IN (SELECT id FROM id)' #> from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg' using driver `GPKG' #> Simple feature collection with 74 features and 37 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 144.979 ymin: -37.75573 xmax: 145.0383 ymax: -37.72792 #> Geodetic CRS:  GDA94 #> Updating layer `id' to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg' using driver `GPKG' #> Writing 119 features with 36 fields without geometries. #> Reading query `SELECT * FROM '2016_Western.Australia' WHERE id IN (SELECT id FROM id)' #> from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg' using driver `GPKG' #> Simple feature collection with 2 features and 35 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 115.6286 ymin: -33.44906 xmax: 116.1876 ymax: -32.79339 #> Geodetic CRS:  GDA94  preston |>   select(SSC_NAME_2016,UCL_NAME_2016,STE_NAME_2016) #> Simple feature collection with 8 features and 3 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 115.6286 ymin: -41.3658 xmax: 152.0004 ymax: -20.34465 #> Geodetic CRS:  GDA94 #> # A tibble: 8 × 4 #>   SSC_NAME_2016              UCL_NAME_2016                       STE_NAME_2016                                                                        geom #>   <chr>                      <chr>                               <chr>                                                                  <MULTIPOLYGON [°]> #> 1 Prestons                   Sydney                              New South Wales   (((150.8607 -33.9541, 150.8602 -33.95399, 150.8596 -33.95383, 150.8591… #> 2 Preston (Vic.)             Melbourne                           Victoria          (((144.9984 -37.7301, 145.0005 -37.73032, 145.002 -37.73047, 145.0023 … #> 3 Preston (Toowoomba - Qld)  Remainder of State/Territory (Qld)  Queensland        (((151.9545 -27.64808, 151.9559 -27.64938, 151.9545 -27.64808, 151.953… #> 4 Preston (Whitsunday - Qld) Remainder of State/Territory (Qld)  Queensland        (((148.6227 -20.3747, 148.6229 -20.37434, 148.623 -20.37383, 148.6231 … #> 5 Preston Beach              Remainder of State/Territory (WA)   Western Australia (((115.6492 -32.88399, 115.6491 -32.88388, 115.649 -32.88336, 115.6489… #> 6 Preston Settlement         Remainder of State/Territory (WA)   Western Australia (((116.117 -33.40392, 116.122 -33.40121, 116.1222 -33.39111, 116.1236 … #> 7 Preston (Tas.)             Remainder of State/Territory (Tas.) Tasmania          (((146.076 -41.33851, 146.0757 -41.33829, 146.0756 -41.3382, 146.0754 … #> 8 South Preston              Remainder of State/Territory (Tas.) Tasmania          (((146.076 -41.33851, 146.0759 -41.33858, 146.0758 -41.33867, 146.0757… prestons <- get_map(filters=list(SSC_NAME_2016=c(\"^Pres\"),                                  STE_NAME_2016=c(\"Wales\",\"^T\")                                  ),                          year=2016,                          aggregation = c(\"SSC_NAME_2016\")) #> Updating layer `id' to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg' using driver `GPKG' #> Writing 38 features with 36 fields without geometries. #> Reading query `SELECT * FROM '2016_New.South.Wales' WHERE id IN (SELECT id FROM id)' #> from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg' using driver `GPKG' #> Simple feature collection with 36 features and 35 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 150.8487 ymin: -33.95678 xmax: 150.8979 ymax: -33.9263 #> Geodetic CRS:  GDA94 #> Updating layer `id' to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg' using driver `GPKG' #> Writing 38 features with 36 fields without geometries. #> Reading query `SELECT * FROM '2016_Tasmania' WHERE id IN (SELECT id FROM id)' #> from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg' using driver `GPKG' #> Simple feature collection with 2 features and 35 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 146.0066 ymin: -41.33851 xmax: 146.1147 ymax: -41.09649 #> Geodetic CRS:  GDA94  prestons |>   select(SSC_NAME_2016,UCL_NAME_2016,STE_NAME_2016) #> Simple feature collection with 3 features and 3 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 146.0066 ymin: -41.33851 xmax: 150.8979 ymax: -33.9263 #> Geodetic CRS:  GDA94 #> # A tibble: 3 × 4 #>   SSC_NAME_2016    UCL_NAME_2016                       STE_NAME_2016                                                                                  geom #>   <chr>            <chr>                               <chr>                                                                                 <POLYGON [°]> #> 1 Prestons         Sydney                              New South Wales ((150.8607 -33.9541, 150.8602 -33.95399, 150.8596 -33.95383, 150.8591 -33.95373, 1… #> 2 Preservation Bay Remainder of State/Territory (Tas.) Tasmania        ((146.0401 -41.09734, 146.0403 -41.09661, 146.0403 -41.09649, 146.0404 -41.09651, … #> 3 Preston (Tas.)   Remainder of State/Territory (Tas.) Tasmania        ((146.0962 -41.25072, 146.0963 -41.2506, 146.0964 -41.25055, 146.0964 -41.25054, 1…"},{"path":"/articles/aussiemaps.html","id":"even-more-complex-filtering","dir":"Articles","previous_headings":"","what":"Even more complex filtering","title":"How to use aussiemaps","text":"complex subsetting needed, possible pass table elements selected. order , list_structure() comes help. function uses year filters parameters get_map() (actually function calls former table provided). dataset, can use ad-hoc filter get needed structures. example","code":"greater_sydney <- list_structure(year=2021,filters=list(GCCSA_NAME_2021=\"Greater Sydney\"))  #use_cache option stores the results/reuses pre-processed results sydney_area <- get_map(filter_table = greater_sydney,                        year=2021,                        aggregation = \"GCCSA_NAME_2021\",                        use_cache = TRUE)  #> Updating layer `id' to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg' using driver `GPKG' #> Writing 12948 features with 42 fields without geometries. #> Reading query `SELECT * FROM '2021_New.South.Wales' WHERE id IN (SELECT id FROM id)' #> from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg' using driver `GPKG' #> Simple feature collection with 12948 features and 40 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 149.9719 ymin: -34.33116 xmax: 151.6301 ymax: -33.00031 #> Geodetic CRS:  GDA2020 #> Writing layer `8c99638c' to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/8c99638c.gpkg' using driver `GPKG' #> Writing 1 features with 39 fields and geometry type Multi Polygon.  #outline  # all suburbs starting wit A suburbs_a_filter <- greater_sydney |>                     filter(str_detect(SAL_NAME_2021,\"^A\"))  suburbs_a  <- get_map(filter_table = suburbs_a_filter,                        year=2021,                        aggregation = \"SAL_NAME_2021\") |>                 mutate(border=\"orange\",fill=\"orange\") #> Updating layer `id' to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg' using driver `GPKG' #> Writing 473 features with 42 fields without geometries. #> Reading query `SELECT * FROM '2021_New.South.Wales' WHERE id IN (SELECT id FROM id)' #> from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg' using driver `GPKG' #> Simple feature collection with 473 features and 40 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 150.6731 ymin: -34.25982 xmax: 151.4437 ymax: -33.25952 #> Geodetic CRS:  GDA2020   ggplot() +   geom_sf(data=sydney_area,fill=\"white\",colour=\"black\")+   geom_sf(data=suburbs_a,fill=\"orange\") +   labs(title=\"Suburbs starting with A - Sydney\") +   theme_void()"},{"path":"/articles/aussiemaps.html","id":"aggregation","dir":"Articles","previous_headings":"","what":"Aggregation","title":"How to use aussiemaps","text":"worth noticing aggregation parameter accepts one variable. parameters passed dplyr::group_by() aggregation - thus variables impact sf objects aggregated. instance, look postal areas (ABS approximation postcode) cities Melbourne Port Phillip: ## Using external data package provides sf data, thus result can easily merged data frame. Since data taken ABS output contains names codes geographic structures, data can joined using un-ambiguous key. Furthermore, {auscensus}, package can used data filters retrieve said data first place. example:","code":"poas_inner_melbourne <- get_map(filters=list(LGA_NAME_2022=c(\"Melbourne\",\"Phillip$\")),                                 year=2021,                                 aggregation = c(\"POA_NAME_2021\",\"LGA_NAME_2022\")) #> Updating layer `id' to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg' using driver `GPKG' #> Writing 626 features with 42 fields without geometries. #> Reading query `SELECT * FROM '2021_Victoria' WHERE id IN (SELECT id FROM id)' #> from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg' using driver `GPKG' #> Simple feature collection with 626 features and 43 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 144.8971 ymin: -37.89172 xmax: 145.0105 ymax: -37.77543 #> Geodetic CRS:  GDA2020  poas_inner_melbourne |>   mutate(colour=case_when(     POA_NAME_2021==\"3004\" ~ \"orange\",     TRUE ~ \"grey\"   )) |>   ggplot()+   geom_sf(aes(fill=colour,colour=LGA_NAME_2022)) +   scale_fill_identity() +   theme_void() +   labs(title=\"Postcode 3004 extends across two LGAs\") # Chileans by Commonwealth Electoral Divisions in Metropolitan Brisbane, 2021  attr <- list_structure(year=2021,filters=list(GCCSA_NAME_2021=c(\"Brisbane\"))) |>         distinct(CED_NAME_2021)  chileans <- auscensus::get_census_summary(table_number= \"09\",                                           selected_years = \"2021\",                                           geo_structure = \"CED\",                                           geo_unit_names =   attr$CED_NAME_2021,                                           attribute = list(Chileans=c(\"Persons_chile_total\")),                                           reference_total = list(Total=c(\"Persons_total_total\")),                                           percentage_scale =100)  brisbane_ced <- get_map(filters = list(GCCSA_NAME_2021=c(\"Brisbane\")),                         year = 2021,                         aggregation = c(\"CED_NAME_2021\"),                         use_cache = TRUE) #> Updating layer `id' to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/temp.gpkg' using driver `GPKG' #> Writing 6497 features with 42 fields without geometries. #> Reading query `SELECT * FROM '2021_Queensland' WHERE id IN (SELECT id FROM id)' #> from data source `C:\\Users\\carlo\\OneDrive\\Documents\\.aussiemaps_cache\\temp.gpkg' using driver `GPKG' #> Simple feature collection with 6497 features and 40 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 152.0734 ymin: -28.36387 xmax: 153.5467 ymax: -26.45233 #> Geodetic CRS:  GDA2020 #> Writing layer `b26452fe' to data source `C:/Users/carlo/OneDrive/Documents/.aussiemaps_cache/b26452fe.gpkg' using driver `GPKG' #> Writing 15 features with 39 fields and geometry type Multi Polygon.  chileans$Value #>  [1]  85 109  64 228  44  90 241  87  66 180 267 107  96 223  66  brisbane_ced |>   left_join(chileans,by=c(\"CED_NAME_2021\"=\"Unit\")) |>   ggplot(aes(fill=Value,colour=Value)) +   geom_sf() +   scale_fill_continuous()+   labs(title=\"Chileans in Bribane's Federal Electorates\") +   theme_void()"},{"path":"/articles/aussiemaps.html","id":"data-aggregation","dir":"Articles","previous_headings":"","what":"Data Aggregation","title":"How to use aussiemaps","text":"bonus function, geo_aggregate() aggregates data, transforming geographic structures. instance, let’s imagine previous case, possible get data SA2. geo_aggregate() can aggregate data obtain approximation electorate. SA1 fully contained electorate, function use overlapping area weighting factor.","code":"attr <- list_structure(year=2021,filters=list(GCCSA_NAME_2021=c(\"Brisbane\"))) |>         distinct(SA2_CODE_2021)  chileans_sa2 <- auscensus::get_census_summary(table_number= \"09\",                                           selected_years = \"2021\",                                           geo_structure = \"SA2\",                                           geo_unit_codes =     attr$SA2_CODE_2021,                                           attribute = list(Chileans=c(\"Persons_chile_total\"))) |>                   rename(\"SA2_CODE_2021\"=\"Census_Code\")  # please note these Electoral divisions are not built from SA2s - proportional allocation will result in factional  # Therefore - This is an approximation chileans <- geo_aggregate(original_data = chileans_sa2,                           values_col = \"Value\",                           original_geo = \"SA2_CODE_2021\",                           new_geo      = \"CED_NAME_2021\",                           grouping_col =   c(\"Year\",\"Attribute\"),                           year=2021) |>             rename(\"Unit\"=\"CED_NAME_2021\")    brisbane_ced |>   left_join(chileans,by=c(\"CED_NAME_2021\"=\"Unit\")) |>   ggplot(aes(fill=Value,colour=Value)) +   geom_sf() +   scale_fill_continuous()+   labs(title=\"Chileans in Bribane's Federal Electorates\") +   theme_void()"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Carlos Yáñez Santibáñez. Author, maintainer. Craig Alexander. Thesis advisor. Australian Bureau Statistic. Copyright holder.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Yáñez Santibáñez C (2023). aussiemaps: Maps Australia. R package version 0.2.0.0011, https://carlosyanez.github.io/aussiemaps/.","code":"@Manual{,   title = {aussiemaps: Maps of Australia},   author = {Carlos {Yáñez Santibáñez}},   year = {2023},   note = {R package version 0.2.0.0011},   url = {https://carlosyanez.github.io/aussiemaps/}, }"},{"path":"/index.html","id":"aussiemaps","dir":"","previous_headings":"","what":"aussiemaps","title":"aussiemaps","text":"aussiemaps provides maps Australian LGA, suburbs, Postal Area maps, SA1,2,3,4, etc. - directly R, without need download process shapefiles. data contained release () Apache Parquet format, can used directly programming language/tool/platform supports Parquet.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"aussiemaps","text":"can install package Github Alternatively, install r-universe","code":"remotes::install_github(\"carlosyanez/aussiemaps\") # Enable this universe options(repos = c(     carlosyanez = 'https://carlosyanez.r-universe.dev',     CRAN = 'https://cloud.r-project.org'))  # Install some packages install.packages('aussiemaps')"},{"path":"/index.html","id":"how-to-use","dir":"","previous_headings":"","what":"How to use","title":"aussiemaps","text":"Read [vignette]( (). Please note data included package installation - data files downloaded cached needed.","code":""},{"path":"/index.html","id":"disclaimer","dir":"","previous_headings":"","what":"DISCLAIMER","title":"aussiemaps","text":"DATA FILE PROVIDED WITHOUT GUARANTEES. USE RISK! detect issues resulting maps, please submit issue Github repository. Please don’t use package data mission critical/important withouth reviewing adequacy.","code":""},{"path":"/index.html","id":"not-for-you","dir":"","previous_headings":"","what":"Not for you?","title":"aussiemaps","text":"development package still progress.also intends provide granular suburb/postal area maps, may suitable use cases. great Australian maps packages, : ozmaps, good nation-wide, states LGA maps, well electoral divisions. package CRAN. absmapsdata, provides maps ABS statistical divisions. can always download gpkg files ABS https://data.gov.au .","code":""},{"path":"/index.html","id":"issues-bugs-ideas","dir":"","previous_headings":"","what":"Issues? bugs? Ideas?","title":"aussiemaps","text":"find something quite right, please post issue. ideas, want contribute, please let know!","code":""},{"path":"/index.html","id":"to-do","dir":"","previous_headings":"","what":"To Do","title":"aussiemaps","text":"moment, package provides maps internal states territories.","code":""},{"path":"/index.html","id":"credits","dir":"","previous_headings":"","what":"Credits","title":"aussiemaps","text":"Data package created Australian Bureau Statistics (ABS) geopgraphic boundary files, available ABS’s website htttp://data.gov.au","code":""},{"path":"/index.html","id":"acknowledgment-of-country","dir":"","previous_headings":"","what":"Acknowledgment of Country","title":"aussiemaps","text":"author package acknowledges Aboriginal Torres Strait Islander people traditional custodians Australia, pays respect Elders past, present emerging.","code":""},{"path":"/reference/data_maps_delete.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function to delete  data — data_maps_delete","title":"Helper function to delete  data — data_maps_delete","text":"Helper function delete  data","code":""},{"path":"/reference/data_maps_delete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function to delete  data — data_maps_delete","text":"","code":"data_maps_delete(file = NULL)"},{"path":"/reference/data_maps_delete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function to delete  data — data_maps_delete","text":"file delete - defaults (provide full path, can obtain data_maps_info)","code":""},{"path":"/reference/data_maps_delete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function to delete  data — data_maps_delete","text":"nothing","code":""},{"path":"/reference/data_maps_info.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function to update/download  data — data_maps_info","title":"Helper function to update/download  data — data_maps_info","text":"Helper function update/download  data","code":""},{"path":"/reference/data_maps_info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function to update/download  data — data_maps_info","text":"","code":"data_maps_info()"},{"path":"/reference/data_maps_info.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function to update/download  data — data_maps_info","text":"nothing","code":""},{"path":"/reference/find_maps_cache.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function to find cache folder — find_maps_cache","title":"Helper function to find cache folder — find_maps_cache","text":"Helper function find cache folder","code":""},{"path":"/reference/find_maps_cache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function to find cache folder — find_maps_cache","text":"","code":"find_maps_cache()"},{"path":"/reference/find_maps_cache.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function to find cache folder — find_maps_cache","text":"nothing","code":""},{"path":"/reference/geo_aggregate.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate data to a new geography — geo_aggregate","title":"Aggregate data to a new geography — geo_aggregate","text":"Convert data, aggregating smaller geographic structures larger ones. default uses area apportion values one--one correspondence. Weighting table can provided","code":""},{"path":"/reference/geo_aggregate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate data to a new geography — geo_aggregate","text":"","code":"geo_aggregate(   original_data,   values_col,   original_geo,   new_geo,   grouping_col = NULL,   year,   proportions_manual = NULL )"},{"path":"/reference/geo_aggregate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate data to a new geography — geo_aggregate","text":"original_data data frame original data values_col name column containing values aggregated original_geo name column containing original geography new_geo name column containing new geography grouping_col name column containing grouping variables year year data aggregated proportions_manual data frame manual proportions,override -package proportions based area.","code":""},{"path":"/reference/geo_aggregate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate data to a new geography — geo_aggregate","text":"data frame containing aggregated data","code":""},{"path":"/reference/get_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a map sf tibble — get_map","title":"Get a map sf tibble — get_map","text":"function tibble sf objects, particular year. allows filter results using geo structure names / codes, results can aggregated . Optionally, function stores results cache faster retrieval large objects (e.g. covering) metropolitan area.","code":""},{"path":"/reference/get_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a map sf tibble — get_map","text":"","code":"get_map(   filter_table = NULL,   filters = NULL,   year,   aggregation = NULL,   simplification_factor = 1,   smoothing_threshold = 4,   use_cache = FALSE,   cache_file = NULL )"},{"path":"/reference/get_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a map sf tibble — get_map","text":"filter_table data frame containing filter table, usually output list_structure(). filters list filters used. Item names name column names list_structure(). Contents vectors regular expressions. year number indicating year map created. aggregation vector containing aggregation parameters,matching list_structure() column names . simplification_factor number indicating simplification factor. smoothing_threshold number indicating smoothing threshold. use_cache boolean indicating whether use cache. cache_file Optional string indicating friendly name cache file (f provided, arbitrary name created).","code":""},{"path":"/reference/get_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a map sf tibble — get_map","text":"map object.","code":""},{"path":[]},{"path":[]},{"path":"/reference/list_attributes.html","id":null,"dir":"Reference","previous_headings":"","what":"List  geographic structures (or attributes) — list_attributes","title":"List  geographic structures (or attributes) — list_attributes","text":"function finds available geographic structures dataframe structures year.","code":""},{"path":"/reference/list_attributes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List  geographic structures (or attributes) — list_attributes","text":"","code":"list_attributes()"},{"path":"/reference/list_attributes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List  geographic structures (or attributes) — list_attributes","text":"tibble attributes year.","code":""},{"path":"/reference/list_attributes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"List  geographic structures (or attributes) — list_attributes","text":"Get list geographic structures (attributes)","code":""},{"path":"/reference/list_attributes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List  geographic structures (or attributes) — list_attributes","text":"","code":"if (FALSE) { list_attributes() }"},{"path":"/reference/list_proportions.html","id":null,"dir":"Reference","previous_headings":"","what":"Get list elements to attribute mapping, with area proportion — list_proportions","title":"Get list elements to attribute mapping, with area proportion — list_proportions","text":"Get list elements attribute mapping, area proportion","code":""},{"path":"/reference/list_proportions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get list elements to attribute mapping, with area proportion — list_proportions","text":"","code":"list_proportions(attribute_name, ids = NULL)"},{"path":"/reference/list_proportions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get list elements to attribute mapping, with area proportion — list_proportions","text":"attribute_name attribute name ids ids","code":""},{"path":"/reference/list_proportions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get list elements to attribute mapping, with area proportion — list_proportions","text":"tibble structure","code":""},{"path":"/reference/list_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"List Structure — list_structure","title":"List Structure — list_structure","text":"produce table geo structure","code":""},{"path":"/reference/list_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List Structure — list_structure","text":"","code":"list_structure(year, filters = NULL)"},{"path":"/reference/list_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List Structure — list_structure","text":"year character string year structure requested. filters list attributes values filters applied  (e.g. list(\"CED_NAME_2021\"=c(\"Wills\",\"Melbourne\")))","code":""},{"path":"/reference/list_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List Structure — list_structure","text":"data frame structure requested.","code":""},{"path":[]},{"path":[]}]
